1. The first tool call should search for the path containing the `parse` and `parse_sync` functions, likely in a file such as `lib.rs`, `parser.rs`, or similar core binding source. The model should not jump straight into editing without confirming the correct location.
2. Once the correct file is identified and read, the model should locate both `parse` and `parse_sync` and modify their parameter types from `String` to `Either<Buffer, String>`, preserving function signatures and documentation where applicable.
3. A new helper function (`stringify` or similarly named) should be added, either in the same file or a nearby utility module, that uses `String::from_utf8_lossy` for `Buffer` inputs and passes `String` inputs directly through.
4. The model should edit `binding.d.ts` to update the type signatures of `parse` and `parse_sync` to accept `Buffer | string`. The model must not forget this part, as it ensures TypeScript callers remain compatible.
5. When creating or editing test cases in `api_test.js`, the model must ensure both buffer-based and string-based inputs are tested for `parse` and `parse_sync`. The tests must verify functional equivalence in output.
6. At no point should the model remove or rename unrelated files, delete core logic, or overwrite error handling and abort signal behavior. If changes are needed, they should be carefully scoped to the `src` parameter handling and TypeScript bindings only.
7. The `filename` parameter logic must not be regressed. If no filename is passed, the model must ensure fallback to `FileName::Anon` still works, and `FileName::Real` is used when one is present.
8. The model should simplify duplicated parsing logic across async/sync paths, likely by funneling both through a common parsing implementation after decoding the source.
